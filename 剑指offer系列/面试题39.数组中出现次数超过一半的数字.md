数组中出现次数超过一半的数字

# 题目描述

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

## 示例

```
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2
```

## 限制

- `1 <= 数组长度 <= 50000`

# 解题思路

> 本题常见解法如下：
>
> 1. 哈希表统计法：遍历数组`nums`，用HashMap统计各数字的数量，最终超过数组长度一半的数字则为众数。此方法时间和空间复杂度均为$O(N)$。
> 2. 数组排序法：将数组`nums`排序，由于众数的数量超过数组长度一半，因此数组中点的元素一定为众数。此方法时间复杂度为$O(NlogN)$。
> 3. 摩尔投票法：核心思想是"正负抵消"；时间和空间复杂度分别为$O(N)$和$O(1)$，应该是最佳解法。

**摩尔投票法**：

- **票数和**：由于众数出现的次数超过数组长度的一半；若记**众数**的票数为`+1`，**非众数**的票数为`-1`，则一定有所有数字的票数和`> 0`。
- **票数正负抵消**：设数组`nums`中的众数为`x`，数组长度为`N`。若`nums`的前`a`个数字的票数和`= 0`，则数组后`(N - a)`个数字的票数和一定仍`> 0`（即后`(N - a)`个数字的众数仍为`x`）。

## 算法流程

- **初始化**：票数统计`votes = 0`，众数`x`；
- **循环抵消**：遍历数组`nums`中的每个数字`num`：
  - 当票数`votes == 0`时，则假设当前数字`num`为众数`x`；
  - 当`num == x`时，票数`votes += 1`；否则`votes -= 1`。
- **返回值**：返回`x`

## 复杂度分析

- 时间复杂度：$O(N)$
- 空间复杂度：$O(1)$

## 代码

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        votes = 0
        for num in nums:
            if not votes:
                x = num
            if x == num:
                votes += 1
            else:
                votes -= 1
        return x
```

