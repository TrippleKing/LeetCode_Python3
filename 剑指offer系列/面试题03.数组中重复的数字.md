数组中重复的数字

# 题目描述

找出数组中重复的数字。在一个长度为n的数组nums里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

## 示例

```
输入：
[2,3,1,0,2,5,3]
输出：2或3
```

## 限制

```
2<=n<=100000
```

# 解题思路

本题方法很多，每个方法都有优缺点，题目也没有限制是否可以使用额外空间，是否可以修改原始数组。如果在面试的时候，需要询问面试官是否有这些限制，并给出对应的解决方案。

在实际的工作中，我们遇到的问题很多时候也不会直接告诉我们有哪些限制，需要我们根据实际情况，具体分析应该使用哪种方法。所以有些面试官可能出的一些题目就是没有说的很清楚，他希望你向他提问，就是为了考察你是不是有考虑得很全面（面试就这样，是和活生生的人对话，不是做题 Accept 就完事，大家要稳，习惯就好，有的时候不能 Accept ，但是面试官看到了你其他方面的素质，其实也会给通过的）。

## 方法一：哈希表

应该是最容易想到，但显然需要额外空间。

特别地，在数组的长度不超过32的时候，使用位运算的技巧可以实现$O(1)$空间复杂度判重，但是这道题不是回溯算法的问题，题目给出的测试用例的长度肯定不止32位，因此，不建议使用位运算的技巧。

分析：这种方法不修改原始数组，但是使用了$O(N)$空间，使用空间换时间，是最正常的思路，时间复杂度是$O(N)$。

## 方法二：排序

排序后，再遍历一遍就知道哪个重复了。

分析：这个方法也比较容易想到，但是排序本身也需要时间，同时修改了原始数组，时间复杂度是$O(NlogN)$。Python语言中排序所用蒂姆排序算法空间复杂度为$O(N)$。

## 方法三：把数组视为哈希表

题目指出`在一个长度为n的数组nums里所有数字都在0~n-1的范围内`。因此，可遍历数组并通过交换操作使元素的**索引**与**值**一一对应（即`nums[i]=i`）。

在遍历中，当第二次遇到数字`x`时，一定有`nums[x]=x`（因为第一次遇到`x`时已经将其交换至`nums[x]`处了）。利用以上方法，即可得到一组重复数字。

### 算法流程

- 遍历数组`nums`，设索引初始值为`i=0`：
  1. 若`nums[i]==i`：说明此数字已在对应索引位置，无需交换，因此执行`i += 1`与`continue`；
  2. 若`nums[nums[i]] == nums[i]`：说明索引`nums[i]`处的元素值也为`nums[i]`，即找到一组相同值，返回此值`nums[i]`；
  3. 否则：当前数字是第一次遇到，因此交换索引为`i`和`nums[i]`的元素值，将此数字交换至对应索引位置。
- 若遍历完毕尚未返回，则返回-1，代表数组中无相同值。

分析：这个思路利用到了数组的元素值的范围恰好和数组的索引是一样的，因此数组本身可以当做哈希表来使用。遍历一遍就可以找到重复值，但是修改了原始数组。时间复杂度$O(N)$：遍历数组使用$O(N)$，每轮遍历的判断和交换操作使用$O(1)$。空间复杂度$O(1)$：使用常数复杂度的额外空间。

### 代码：

```python
class Solution:
    def findRepeatNumber(self, nums: List[int]) -> int:
        for i in range(len(nums)):
            if nums[i] == i:
                i += 1
                continue
            elif nums[nums[i]] == nums[i]:
                return nums[i]
            else:
                nums[nums[i]], nums[i] = nums[i], nums[nums[i]]
        return -1
```

