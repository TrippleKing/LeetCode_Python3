n个骰子的点数

# 题目描述

把`n`个骰子仍在地上，所有骰子朝上一面的点数之和为`s`。输入`n`，打印出`s`的所有可能的值出现的概率。

你需要用一个浮点数数组返回答案，其中第`i`个元素代表这`n`个骰子所能掷出的点数集合中第`i`小的那个概率。

## 示例1

```
输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
```

## 示例2

```
输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
```

## 限制

- `1 <= n <= 11`

# 解题思路

根据概率公式，点数之和`s`出现概率计算公式为：
$$
P(k) = \frac{s出现的次数}{总次数}
$$
投掷`n`个骰子，所有点数出现的总次数是$6^n$，因为一共有`n`个骰子，每个骰子的点数都有`6`中可能出现的情况。

由此，问题就转化为求解`s`出现的次数的问题。

我们利用**动态规划**进行求解：

- **表示状态**：利用二维数组`dp[i][j]`表示当投完第`i`个骰子后，点数之和为`j`的**次数**。
- **转移方程**：单看第`i`个骰子，它的点数可能是`1, 2, 3, 4, 5, 6`六种情况，因此，投掷完第`i`个骰子后点数之和为`j`的次数，可以由投掷完第`i - 1`个骰子后对应点数和`j-1, j-2, j-3, j-4, j-5, j-6`出现的次数之和转移过来。
- **边界处理**：`dp[1][j]`若仅有`1`个骰子，那么点数和的情况为`1, 2, 3, 4, 5, 6`且每种情况出现的次数都是`1`。

## 复杂度分析

> 其实题目中限制了`n`不会取到太大，否则即使用动态规划也很容易超时。

- 时间复杂度：$O(N^2)$
- 空间复杂度：$O(N^2)$

## 代码

```python
class Solution:
    def twoSum(self, n: int) -> List[float]:
        # 1 <= n <= 11
        dp =[[0 for _ in range(6*11+1)]for _ in range(n+1)]
        for i in range(1, 7):
            dp[1][i] = 1
        
        for i in range(2, n+1):
            for j in range(i, 6*i+1):
                for k in range(1, 7):
                    if j-k > 0:
                        dp[i][j] += dp[i-1][j-k]
        res = []
        for i in range(n, 6*n+1):
            res.append(dp[n][i]/(6**n))

        return res
```

## 空间优化

通过**转移方程**可以看出在计算`dp[i][j]`时仅与`i - 1`维有关，我们可以借助滚动数组的思想将二维数组压缩为一维数组。

## 代码

```python
class Solution:
    def twoSum(self, n: int) -> List[float]:
        # 1 <= n <= 11
        dp = [0 for _ in range(6*11 + 1)]
        for i in range(1, 7):
            dp[i] = 1
        
        for i in range(2, n+1):
            for j in range(6*i, i-1, -1):
                for k in range(1, 7):
                    if j-k > i-1: # 注意这里的判别条件与上面的代码不一样
                        dp[j] += dp[j-k]
        res = []
        all_num = 6**n
        for i in range(n, 6*n+1):
            res.append(dp[i]/all_num)

        return res
```

