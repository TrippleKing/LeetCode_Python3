正则表达式匹配

# 题目描述

请实现一个函数来匹配包含`"."`和`"*"`的正则表达式。模式中的字符`"."`表示任意一个字符，而`"*"`表示它前面的字符可以出现任意次（含0次）。本题中，匹配是指字符串的所有字符匹配整个模式。例如，`"aaa"`与模式`"a.a"`和`"ab*ac*a"`匹配，但与`"aa.a"`和`"ab*a"`均不匹配。

## 示例1

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

## 示例2

```
输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```

## 示例3

```
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```

## 示例4

```
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
```

## 示例5

```
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```

## 提示

- `s`可能为空，且只包含`a-z`的小写字母。
- `p`可能为空，且只包含`a-z`的小写字母以及字符`"."`和`"*"`，无连续的`"*"`。

# 解题思路

> 本题可以用动态规划的思想进行解题，一步一步分解情况，还是比较容易理解的。
>
> 也可以通过递归的思想进行解题，递归理解起来可能会比动态规划要困难一些。

## 方法一：动态规划

动态规划的问题，建议多在纸上写一写，都在脑子里想，挺容易混乱的。

### 状态

设`dp[i][j]`表示的状态是主串`s`的前`i`项与模式串`p`的前`j`项是否匹配。

（注意：`i,j`对应在`s`和`p`中的索引为`i-1,j-1`）

### 转移方程

在计算`dp[i][j]`的状态时，`dp[i-1][j-1]`的状态已经明确了，通过以下情况的判断，就能分析出`dp[i][j]`的状态：

1. 主串`s`的第`i`项（`s[i-1]`）与模式串`p`的第`j`项（`p[j-1]`）相等，且`p`的第`j`项为`常规字符`：那么，`dp[i][j]`的状态由`dp[i-1][j-1]`的状态唯一确定，即`dp[i][j] = dp[i-1][j-1]`。
2. 模式串`p`的第`j`项（`p[j-1]`）为`"."`，能匹配任意字符：那么`dp[i][j]`的状态也由`dp[i-1][j-1]`的状态唯一确定，即`dp[i][j] = dp[i-1][j-1]`。
3. 模式串`p`的第`j`项（`p[j-1]`）为`"*"`，对前一个字符重复任意次，假设`p[j-2] = c`，其中`c`可以是`常规字符`也可以是`"."`，分以下两种情况讨论：
   - **情况一**：`c`为`常规字符`且`c != s[i-1]`，则相当于`c`重复0次，且`c*`这一整体不起作用，此时`dp[i][j]`的状态应由`dp[i][j-2]`唯一确定，即`dp[i][j] = dp[i][j-2]`。
   - **情况二**：`c`为`常规字符`且`c = s[i-1]`或者`c = "."`，这种情况下，也有可能是需要对`c`重复0次，比如`s = "ab", p = "abb*"`或者`s = "ab", p = "ab.*"`，此时，依然需要忽略`c*`，即`dp[i][j] = dp[i][j-2]`；当需要对`c`重复多次时，比如`s = "abbb", p = "ab*"`或者`s = "abbb", p = "a.*"`，我们忽略`s`的`i`项，考虑`s`的前`i-1`项与`p`的前`j`项做匹配，即`dp[i][j] = dp[i-1][j]`
4. 其他情况：`dp[i][j] = False`。

## 初始化（边界情况）

- `dp[0][0]`：空主串和空模式串，显然是匹配的，为`True`。
- `dp[0][1]...dp[0][m]`：空主串和非空模式串，需要计算，**不要想当然得以为是False**。（比如`s = "", p = "a*b*c*"`）
- `dp[1][0]...dp[n][0]`：非空主串和空模式串，显然为`False`。

## 复杂度分析

> 设$N,M$为主串长度和模式串的长度

- 时间复杂度：$O(NM)$，`dp`二维矩阵其实大小是$(N+1)\times(M+1)$。每个位置计算一次。
- 空间复杂度：$O(NM)$，`dp`二维矩阵的空间。

## 代码

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        # 边界情况，非空主串与空模式串
        if not p: return not s
        
        if not s and len(p) == 1: return False
        n = len(s)
        m = len(p)
        dp = [[False for _ in range(m+1)] for _ in range(n+1)]
        
        dp[0][0] = True
        dp[0][1] = False
        
        # 边界情况，空主串与非空模式串
        for i in range(2, m+1):
            if p[i-1] == "*":
                dp[0][i] = dp[0][i-2]
        
        for i in range(1, n+1):
            for j in range(1, m+1):
                if p[j-1] =="." or p[j-1] == s[i-1]:
                    dp[i][j] = dp[i-1][j-1]
                
                elif p[j-1] == "*":
                    if p[j-2] == s[i-1] or p[j-2] == ".":
                        dp[i][j] = dp[i-1][j] or dp[i][j-2]
                    elif p[j-2] != s[i-1]:
                        dp[i][j] = dp[i][j-2]
        
        return dp[n][m]
```

## 方法二：递归

首先，我们考虑只有 `'.'` 的情况。这种情况会很简单：我们只需要从左到右依次判断 `s[i]` 和 `p[i]` 是否匹配。

```python
def isMatch(self,s:str, p:str) -> bool:
    if not p: return not s # 边界条件

    first_match = s and p[0] in {s[0],'.'} # 比较第一个字符是否匹配

    return first_match and self.isMatch(s[1:], p[1:])
```

如果有星号，它会出现在` p[1]` 的位置，这时有两种情况：

- 星号代表匹配 0 个前面的元素。如 `'##'` 和 `a*##`，这时我们直接忽略 p 的 `a*`，比较 `##`和 `##`；
- 星号代表匹配一个或多个前面的元素。如 `aaab` 和 `a*b`，这时我们将忽略 `s` 的第一个元素，比较 `aab` 和 `a*b`。
  以上任一情况忽略掉元素进行比较时，剩下的如果匹配，我们认为` s` 和 `p` 是匹配的。

## 代码

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        if not p: return not s
        # 第一个字母是否匹配
        first_match = bool(s and p[0] in {s[0],'.'})
        # 如果 p 第二个字母是 *
        if len(p) >= 2 and p[1] == "*":
            return self.isMatch(s, p[2:]) or \
            first_match and self.isMatch(s[1:], p)
        else:
            return first_match and self.isMatch(s[1:], p[1:])
```

