数组中数字出现的次数

# 题目描述

一个整数数组`nums`里除了两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是$O(n)$，空间复杂度是$O(1)$。

## 示例1

```
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
```

## 示例2

```
输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
```

## 限制

- `2 <= nums.length <= 10000`

# 解题思路

假设，我们抛开复杂度的要求，最先想到的解题方法基本上是暴力遍历：

- 先选出数组`nums`中第一个元素（比如记为a）；
- 再遍历剩下的元素，查看是否有相同的元素a；
- 再选出第二个元素，以此类推。

这种方法的时间复杂为$O(n^2)$，空间复杂度为$O(1)$。

更进一步，借助字典，利用`collections.Counter()`对数组`nums`进行统计，然后进行一次遍历即可得到出现次数为1的元素。该方法的时间复杂度为$O(n)$，但是空间复杂度也为$O(n)$。

我们再思考，如果数组`nums`中只有一个数字出现了一次，其他数字都出现了两次，可以怎么做？可以使用异或操作得到结果。（嗯？什么是异或？）

## 补充知识

我们先补充一点有关异或的知识，具体的与"位运算"相关知识，会在之后专门整理一次。

1. 异或的性质

   两个数字异或的结果`a^b`是将a和b的**二进制**每一位进行运算，得出的数字。

   运算的逻辑是：如果同一位的数字相同则为0，不同则为1。

2. 异或的规律
   - 任何数和它本身异或，结果为`0`。即`a^a=0`
   - 任何数和0异或，结果为它本身。即`a^0=a`
   - 异或满足交换律。即`a^b^c=a^c^b`

## 回到解题思路

结合上述异或操作的相关知识，如果数组`nums`中只有一个数字出现了一次，其他数字都出现了两次，那么对整个数组进行一次全员异或即可得到结果。（这段话想清楚了再往下看）

现在数组中有两个数字出现了一次，其他数字都出现了两次，如果我们能够将该数组`nums`拆分成两个数组`nums1`和`nums2`，这两个数组中有且仅有一个数字出现了一次，其他数字出现了两次，那么再对两个数组分别进行全员异或，即可得到答案。

那么问题就转变为如何正确拆分数组`nums`？思路如下：

1. 先对原始数组`nums`进行一次全员异或（假设`nums`中两个仅出现一次的数字为a和b），异或结果为`a^b`，记为`xor`；
2. 那么`xor`（以二进制看）至少在某一位上为1，用`mask`记录这个位置（设置该位置为1，其余位置为0）；
3. 利用`mask`来划分原始数组`nums`，原数组中元素和`mask`进行"与运算，&"，如果该位置上为1，则划分进数组`nums1`；否则划分进数组`nums2`；
4. 最后再对数组`nums1`和`nums2`分别进行一次全员异或，即可得到答案。

## 举个例子

看了上述思路，可能还是有很多问号，我们举个实例简单说明一下，大家把实例和思路对照起来可以加深理解。

```
输入：[4,1,4,6]
二进制形式：[0100,0001,0100,0110]
第一次全员异或：0100^0001^0100^0110 = 0111 = xor
找到首个为1的位置：mask = 0001
以mask拆分nums：0100 & 0001 = 0000；0001 & 0001 = 0001；0100 & 0001 = 0000；0110 & 0001 = 0000
得到nums1; nums2：nums1=[1];nums2=[4,4,6]
分别对nums1和nums2进行全员异或，得到结果：[1,6]
```

如果感觉自己理解起来有些吃力，可能需要补习一下计算机中"位运算"的相关知识。

## 代码

```python
class Solution:
    def singleNumbers(self, nums: List[int]) -> List[int]:
        xor = 0
        mask = 1
        num1, num2 = 0, 0
        # 全员异或得到 xor
        for num in  nums:
            xor ^= num
        # 寻找xor首个为1的位置 mask
        # mask = xor & (-xor) # 可以直接与运算得到mask
        while mask & xor == 0:
            mask = mask << 1
        # 拆分nums，同时进行异或操作
        # 这里就没有再把拆分的元素放进列表里（因为没必要）
        for num in nums:
            if mask & num:
                num1 ^= num
            else:
                num2 ^= num
        return [num1, num2]
```



