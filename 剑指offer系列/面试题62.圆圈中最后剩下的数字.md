圆圈中最后剩下的数字

# 题目描述

`0, 1, ..., n-1`这`n`个数字排成一个圆圈，从数字`0`开始，每次从这个圆圈里删除第`m`个数字。求出这个圆圈里剩下的最后一个数字。

例如，`0, 1, 2, 3, 4`这`5`个数字组成一个圆圈，从数字`0`开始每次删除第`3`个数字，则删除的前`4`个数字依次是`2, 0, 4, 1`，因此最后剩下的数字是`3`。

## 示例1

```
输入: n = 5, m = 3
输出: 3
```

## 示例2

```
输入: n = 10, m = 17
输出: 2
```

## 限制

- `1 <= n <= 10^5`
- `1 <= m <= 10^6`

# 解题思路

**重点提示**：仅关注最终留下的数字的**索引号**的变化情况。

这个问题实际上是约瑟夫问题，这个为的描述是：

> N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。

**问题转换**

由于索引号是数字，然后每个元素也是数字，可能在解释的时候会引起混淆，我们使用**字母**来解释，本质当然是一样的。

下面这个例子是`N = 8, M = 3`的例子。

我们定义`f(n, m)`表示最后剩下那个**字母**的`索引号`，我们只关心最后剩下的字母的索引号的变化情况。

![约瑟夫环1](http://xyao-imgs.oss-cn-beijing.aliyuncs.com/img/约瑟夫环1.png)

从8个字母开始，每次删去一个字母，然后把删去字母的后一个字母作为开头重新编号

- 第一次`C`被删去，总数变为`7`，`D`作为开头（最终剩下的`G`的索引号从`6`变成`3`）
- 第二次`F`被删去，总数变为`6`，`G`作为开头（最终剩下的`G`的索引号从`3`变成`0`）
- 第三次`A`被删去，总数变为`5`，`B`作为开头（最终剩下的`G`的索引号从`0`变成`3`）
- 依次类推，当只剩下`G`时，它的索引号必定是`0`

**从结果反推**

根据上图我们知道了`G`的索引号变化过程，我们来反推一下从`N = 7`到`N = 8`的过程。

我们先把`C`补回来，然后右移`m`个字母，发现溢出了，再把溢出的补充在最前面，这样就能反推。如下图所示。

![约瑟夫环2](http://xyao-imgs.oss-cn-beijing.aliyuncs.com/img/约瑟夫环2.png)

因此，我们可以得到递推公式`f(8, 3) = (f(7, 3) + 3) % 8`

推广到一般式，即`f(n, m) = (f(n-1, m) + m) % n`

边界情况，`n = 1`时，`f(n, m) = 0`

## 复杂度分析

- 时间复杂度：$O(N)$
- 空间复杂度：$O(1)$，若使用递归方法求解，则空间复杂度为$O(N)$；若使用迭代方法求解则为$O(1)$

## 代码

```python
class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        # 共n个数字，最终只剩1个
        # 每一次删除1个数字
        # 即要删除(n-1)次
        # 每一次的跨度为m
        # 仅关注最后剩下的元素的索引号变化情况
        f = 0
        for i in range(2, n+1):
            f = (m + f) % i
        
        return f
```

