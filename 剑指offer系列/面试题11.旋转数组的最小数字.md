旋转数组的最小数字

# 题目描述

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出数组的最小元素。例如，数组`[3,4,5,1,2]`为`[1,2,3,4,5]`的一个旋转，该数组的最小值为`1`。

## 示例1

```
输入：[3,4,5,1,2]
输出：1
```

## 示例2

```
输入：[2,2,2,0,1]
输出：0
```

# 解题思路

题目的本质其实是找出给定数组中的最小元素，可以直接使用`min()`函数，则时间复杂度为$O(N)$。

再深入思考一下，对于数组的查找问题是否可以使用**二分查找**解决（注意：使用二分查找需要原数组为有序数组），原数组显然不是有序数组，但仍存在一定的特殊性，例如可以划分为两个有序数组，如下图所示：

![二分查找.jpg](http://q9qozit0b.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.JPG)

## 算法流程

1. 循环二分：设置$i,j$指针分别指向`numbers`数组左右两端，$m=(i+j)//2$为每次二分的中点（`//`代表向下取整法，因此恒有$i\le m<j$），可分为以下三种情况：

   （1）当`numbers[m]>numbers[j]`时：$m$一定在左排序数组中，即旋转点$x$一定在$[m+1,j]$闭区间内，因此执行$i=m+1$；

   （2）当`numbers[m]<numbers[j]`时：$m$一定在右排序数组中，即旋转点$x$一定在$[i,m]$闭区间内，因此执行$j=m$；

   （3）当`numbers[m]=numbers[j]`时：无法判断$m$在哪个排序数组中，即无法判断旋转点$x$在$[i,m]$还是$[m+1,j]$区间内。**解决方案**：执行$j=j-1$缩小判断范围。

2. 返回值：当$i=j$时跳出二分循环，并返回`numbers[i]`即可。

分析`numbers[m]=numbers[j]`的情况：

1. 无法判断$m$在左排序数组还是在右排序数组：设以下两个旋转点值为0的示例数组，当$i=0,j=4$时$m=2$，两示例结果如下：

   （1）例`[1,0,1,1,1]`：旋转点$x=1$，因此$m=2$在右排序数组中。

   （2）例`[1,1,1,0,1]`：旋转点$x=3$，因此$m=2$在做排序数组中。

2. 执行$j=j-1$操作的正确性证明：只需要证明每次执行操作后，旋转点的值仍在$[i,j]$区间内即可：

   （1）若$m$在右排序数组中：`numbers[m]=numbers[i]`，因此数组`[m,j]`区间内所有元素值相等，执行$j=j-1$只会抛弃一个重复值，因此旋转点的值仍在$[i,j]$区间内。

   （2）若$m$在左排序数组中：由于`左排序数组任一元素 >= 右排序数组任一元素`，因此可以推出旋转点元素值`numbers[x]<=numbers[j]=numbers[m]`，则有：

   - 若`numbers[x]<numbers[j]`：即$j$左方仍有值更小的元素，执行$j=j-1$后旋转点的值仍在$[i,j]$区间内。
   - 若`numbers[x]=numbers[j]`：不论$x$是否等于$j$，执行$j=j-1$后，都能保证`numbers[m]`仍在数组中。

总结：此方法可以保证返回值`numbers[i]`等于旋转点的值`numbers[x]`；但在少数特例下$i\ne x$。题目只要求返回"旋转点的值"而非索引，因此可行。

## 复杂度分析

- 时间复杂度：$O(logN)$，在特例情况下（如`[1,1,1,1]`，会退化到$O(N)$）。
- 空间复杂度：$O(1)$。

## 代码

```python
class Solution:
    def minArray(self, numbers: [int]) -> int:
        i = 0
        j = len(numbers) - 1
        while i < j:
            m = (i+j)//2
            if numbers[m] > numbers[j]:
                i = m+1
            elif numbers[m] < numbers[j]:
                j = m
            else:
                j = j-1
        return numbers[i]
```

