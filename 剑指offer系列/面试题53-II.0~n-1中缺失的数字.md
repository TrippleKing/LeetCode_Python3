0~n-1中缺失的数字

# 题目描述

一个长度为`n-1`的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围`0 ~ n-1`内的`n`个数字中有且仅有一个数字不在该数组中，请找出这个数字。

## 示例1

```
输入: [0,1,3]
输出: 2
```

## 示例2

```
输入: [0,1,2,3,4,5,6,7,9]
输出: 8
```

## 限制

- `1 <= 数组长度 <= 10000`

# 解题思路

本题直接遍历求解，应该比较容易想到，但需要注意一种特殊情况，如对于`[0, 1, 2, 3, 4, 5, 6, 7]`，看似每个位置上都出现了正确的数字，但应返回`8`，表明其缺失了数字`8`。

不过，对于排序数组中的搜索问题，考虑**二分法**也应该是容易想到的。

根据题意，数组可以按照以下规则划分为两部分：

- **左子数组**：`nums[i] = i`；
- **右子数组**：`nums[i] != i`。

需要求解的缺失的数字等于**右子数组的首个元素**对应的索引；利用**二分查找**查找该元素；

**算法解析**：

- **初始化**：左边界`i = 0`，右边界`j = len(nums)-1`，代表闭区间`[i, j]`；
- **循环二分**：当`i > j`时跳出
  - 计算中点`mid = (i + j) // 2`
  - 若`nums[mid] = mid`，则执行`i = mid + 1`
  - 若`nums[mid] != mid`，则执行`j = mid - 1`
- **返回值**：返回`i`即可

## 复杂度分析

- 时间复杂度：$O(\log N)$
- 空间复杂度：$O(1)$

## 代码

```python
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        i, j = 0, len(nums)-1
        while i <= j:
            mid = (i + j) // 2
            if nums[mid] == mid:
                i = mid + 1
            else:
                j = mid - 1
        return i
```

