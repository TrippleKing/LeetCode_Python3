二进制中1的个数

# 题目描述

请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如，把9表示成二进制是1001，有2位是1。因此，如果输入9，则该函数输出2。

## 示例1

```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

## 示例2

```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```

## 示例3

```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

# 解题思路

> 本题显然是与位运算有关。

## 补充知识

- **与运算**：&，设有二进制数字$n$，则有：
  - 若`n & 1 = 0`，则$n$二进制**最右一位**为0；
  - 若`n & 1 = 1`，则$n$二进制**最右一位**为1。

## 方法一：逐位判断

根据与运算的特点，考虑一下**循环判断**：

1. 判断$n$最右一位是否为1，根据结果计数。
2. 将$n$右移一位（本题需要把数字$n$看作无符号数，因此使用**无符号右移**操作）。

## 复杂度分析

- 时间复杂度：$O(log(N))$，此算法循环内部仅有**移位**、**与运算**、**加法**等基本运算，占用$O(1)$；逐位判断需循环$logN$次，其中$logN$代表数字$n$最高位1的所在位数。
- 空间复杂度：$O(1)$

## 代码

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0
        while n:
            res += n & 1
            n >>= 1
        return res
```

## 方法二：巧用`n & (n-1)`

- $(n-1)$解析：二进制数字$n$最右边的1变成0，此1右边的0都变成1.
- `n & (n-1)`​解析：二进制数字$n$最右边的1变成0，其余不变。

附图解释：

<img src="http://q9qozit0b.bkt.clouddn.com/%E4%BD%8D%E8%BF%90%E7%AE%97.JPG" alt="位运算.jpg" style="zoom:67%;" />

这样就可以变相得用`n & (n-1)`代替移位操作

## 复杂度分析

- 时间复杂度：$O(M)$，`n & (n-1)`操作仅有减法和与运算，占用$O(1)$；设$M$为二进制数字$n$中1的个数，则需循环$M$次（每轮消去一个1），占用$O(M)$。
- 空间复杂度：$O(1)$。

## 代码

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0
        while n:
            res += n & 1
            n &= n-1
        return res
```

