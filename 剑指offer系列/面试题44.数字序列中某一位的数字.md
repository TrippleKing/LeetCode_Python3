数字序列中某一位的数字

# 题目描述

数字以`0123456789101112131415...`的格式序列化到一个字符序列中，第`5`位（从下标`0`）开始计数是`5`，第`13`位是`1`，第`19`位是`4`，等等。

## 示例1

```
输入：n = 3
输出：3
```

## 示例2

```
输入：n = 11
输出：0
```

## 限制

- `0 <= n < 2^31`

# 解题思路

> 这是一个找数学规律的题。

通过观察下表，可以看出一定的规律：

| 数字范围  | 数量 | 位数 | 占多少位 |
| :-------: | :--: | :--: | :------: |
|    1-9    |  9   |  1   |    9     |
|   10-99   |  90  |  2   |   180    |
|  100-999  | 900  |  3   |   2700   |
| 1000-9999 | 9000 |  4   |  36000   |
|    ...    | ...  | ...  |   ...    |

我们可以根据给定的第`n`位，反推出其对应的数`num`：

例如：给定`n = 2901`，得到`2901 = 9 + 180 + 2700 + 12`，则说明其对应的数字一定是个`4`位数，`num = 1000 + (12 - 1)//4 = 1000 + 2 = 1002`，即对应的数为`1002`，具体定位在哪个数字可以由`定位1002中的位置 = （12 - 1）% 4 = 3`，可以得到位于`"1002"`的第`3`位，即`str(1002)[3] = "2"`。

根据上面的例子，可能大家已经明白如何解题了。对于`n`，我们不断循环减少每个位数最多能占几位，如`n - 9 > 0`，说明`n`对应的数字肯定不是一位数，以此类推。

## 复杂度分析

- 时间复杂度：$O(\log n)$，所求数位$n$对应数字$num$的位数`i`最大为$O(\log n)$；第一步最多循环$O(\log n)$次；第三步中将$num$转化为字符串使用$O(\log n)$时间；
- 空间复杂度：$O(\log n)$，将数字$num$转化为字符串`str(num)`，占用$O(\log n)$的额外空间。

## 代码

```python
class Solution:
    def findNthDigit(self, n: int) -> int:
        """
        找规律
        数字范围     数量      位数     占多少位
        1-9         9          1       9
        10-99       90         2       180
        100-999     900        3       2700
        1000-9999   9000       4       36000
        ...         ...       ...      ...
        """
        i = 1
        digit = 1
        count = 9 * i * digit
        while n - count > 0: # 1
            n -= count
            digit = 10**i
            i += 1
            count = 9 * i * digit
            
        num = digit + (n - 1) // i # 2
        return int(str(num)[(n - 1) % i]) # 3  
```



