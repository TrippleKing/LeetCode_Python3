数值的整数次方

# 题目描述

实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

## 示例1

```
输入: 2.00000, 10
输出: 1024.00000
```

## 示例2

```
输入: 2.10000, 3
输出: 9.26100
```

## 示例3

```
输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
```

## 说明

- `-100.0 < x < 100.0`
- n是32位有符号整数，其数值范围是$[-2^{31},2^{31},-1]$。

# 解题思路

> 求$x^n$最简单的方法是通过循环将$n$个$x$乘起来，依次求$x^1,x^2,...,x^{n-1},x^n$，时间复杂度为$O(n)$。
>
> **快速幂法**，可将时间复杂度降低至$O(\log n)$，从"二进制"和"二分法"角度对快速幂法进行解析。

## 从二进制角度看快速幂

> 利用十进制数字$n$的二进制表示，可以对快速幂进行数学化解释。

- 对于任何十进制正整数$n$，设其二进制为$b_m...b_3b_2b_1$，（$b_i$为二进制某个位置，取值为$0$或$1$），则有：
  - **二进制转十进制**：$n=2^0b_1+2^1b_2+2^2b_3+...+2^{m-1}b_m$（即二进制转十进制公式）
  - **幂的二进制展开**：$x^n=x^{2^0b_1+2^1b_2+2^2b_3+...+2^{m-1}b_m}=x^{2^0b_1}x^{2^1b_2}x^{2^@b_3}...x^{2^{m-1}b_m}$。
- 根据上述推导，可把计算$x^n$转化为解决以下两个问题：
  1. 计算$x^1,x^2,x^4,...,x^{2^{m-1}}$的值：循环执行赋值操作$x=x^2$即可；
  2. 获取二进制各位置$b_1,b_2,...,b_{m}$的值：循环执行以下操作即可：
     - `n & 1`（与操作）：判断$n$二进制最右一位是否为1；
     - `n >> 1`）（移位操作）：$n$右移一位（即删除最后一位）。
- 利用上述操作，可以在循环中依次计算$x^{2^0b_1},x^{2^1b_2},x^{2^@b_3},...,x^{2^{m-1}b_m}$的值，并将其累计相乘即可。
  - 当$b_i=0$时：$x^{2^{i-1}b_i}=1$；
  - 当$b_i=1$时：$x^{2^{i-1}b_i}=x^{2^{i-1}}$。

附下图，辅助理解：

<img src="http://q9qozit0b.bkt.clouddn.com/%E5%BF%AB%E9%80%9F%E5%B9%82_%C2%B7.JPG" alt="二进制.jpg" style="zoom:67%;" />

## 从二分法角度看快速幂

> 快速幂实际上是二分思想的一种应用

- **二分推导**：$x^n=x^{\frac{n}{2}}\times x^{\frac{n}{2}}=(x^2)^{\frac{n}{2}}$，令$\frac{n}{2}$为整数，则需要分为奇数/偶数两种情况（"//"记为向下取整除法符号）：
  - 当$n$为偶数时：$x^n=(x^2)^{n//2}$；
  - 当$n$为奇数时：$x^n=x(x^2)^{n//2}$，即会多出一项$x$。
- **幂结果获取**：
  - 根据二分推导，可通过循环$x=x^2$操作，每次把幂从$n$降至`n//2`，直至将幂降为0；
  - 设`res=1`，则初始状态$x^n=x^n\times res$。在循环二分时，每当$n$为奇数时，将多出一项$x$乘入`res`，则最终可化至$x^n=x^0\times res=res$，返回`res`即可。

附下图，辅助理解：

<img src="http://q9qozit0b.bkt.clouddn.com/%E5%BF%AB%E9%80%9F%E5%B9%82_1.JPG" alt="二分法.jpg" style="zoom:67%;" />

- **转化为位运算**：
  - 向下整除`n//2`等价于右移一位`n>>1`；
  - 取余数`n%2`等价于判断二进制最右一位值`n&1`。

## 算法流程

1. 当`x=0`时：直接返回0（避免后续`x=1/x`赋值报错）。
2. 初始化`res=1`；
3. 当`n<0`时，把问题转换为`n>=0`的范围内，执行`x=1/x;n=-n`；
4. 循环计算：当`n=0`时跳出循环：
   1. 当`n&1=1`时：将当前`x`乘入`res`（即`res *= x`）；
   2. 执行`x=x^2`（即`x *= x`）；
   3. 执行右移一位（即`n >>= 1`）
5. 返回`res`。

## 复杂度分析

- 时间复杂度：$O(logN)$
- 空间复杂度：$O(1)$

## 代码

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if x == 0:
            return 0
        res = 1
        if n < 0:
            x, n = 1/x, -n
        while n:
            if n & 1:
                res *= x
            x *= x
            n >>= 1
        return res
```

