字符串的排列

# 题目描述

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

## 示例

```
输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]
```

## 限制

- `1 <= s的长度 <= 8`

# 解题思路

**排列方案数量**：对于一个长度为`n`的字符串（假设字符互不重复），其排列共有$n\times(n-1)\times(n-2)...\times 2\times 1$种方案。

**排列方案的生成方法**：根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过**字符交换**，先固定第`1`位字符（$n$种情况）、再固定第`2`位字符（$n-1$种情况）、... 、最后固定第$n$为字符（$1$种情况）。

**重复方案与剪枝**：当字符串存在重复字符时，排列方案中也存在重复方案。为排除重复方案，需在固定某字符时，保证"每种字符只在此位置固定一次"，即遇到重复字符时不交换，直接跳过。从DFS角度看，可以称为"剪枝"。

## 算法流程

- **终止条件**：当`x=len(s)-1​`时，代表所有位置已固定（最后一位只有$1$种情况），则将当前组合`s`转化为字符串并加入`res`，并返回。

- **递推参数**：当前固定位`x`；
- **递推工作**：初始化一个`set`，用于排除重复的字符；将第`x`位字符与`i in [x, len(s)]`字符分别交换，并进入下层递归；
  - **剪枝**：若`s[i]`在`set`中，代表是重复字符，因此"剪枝"；
  - 将`s[i]`加入`set`，以便之后遇到重复字符时剪枝；
  - **固定字符**：将字符`s[i]`和`s[x]`交换，即固定`s[i]`为当前字符；
  - **开启下层递归**：调用`dfs(x+1)`，即开始固定第`x+1`个位置；
  - **还原交换**：将字符`s[i]`和`s[x]`交换（还原之前的交换）

## 复杂度分析

- 时间复杂度：$O(N!)$，$N$为字符串`s`的长度；时间复杂度与字符串排列的方案数成线性关系。
- 空间复杂度：$O(N^2)$，全排列的递归深度为$N$，系统累计使用栈空间大小为$O(N)$；递归中辅助`set`累计存储的字符数量最多为$N+(N-1)+...+2+1=\frac{N(N+1)}{2}$，即占用$O(N^2)$的额外空间。

## 代码

```python
class Solution:
    def permutation(self, s: str) -> List[str]:
        s_list = list(s)
        res = []

        def dfs(idx):
            if idx == len(s_list) - 1:
                res.append("".join(s_list))
                return
            visited = set()
            for i in range(idx, len(s_list)):
                if s_list[i] in visited: continue
                visited.add(s_list[i])
                s_list[i], s_list[idx] = s_list[idx], s_list[i]
                dfs(idx+1)
                s_list[i], s_list[idx] = s_list[idx], s_list[i]
        
        dfs(0)
        return res
```



