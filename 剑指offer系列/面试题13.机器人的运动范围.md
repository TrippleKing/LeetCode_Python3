机器人的运动范围

# 题目描述

地上有一个m行n列的方格，从坐标`[0,0]`到坐标`[m-1,n-1]`。一个机器人从坐标`[0,0]`的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格`[35,37]`，因为`3+5+3+7=18`。但它不能进入方格`[35,38]`，因为`3+5+3+8=19`。请问该机器人能够到达多少个格子？

## 示例1

```
输入：m = 2, n = 3, k = 1
输出：3
```

## 示例2

```
输入：m = 3, n = 1, k = 0
输出：1
```

## 提示

- `1 <= n,m <= 100`
- `0 <= k <= 20`

# 解题思路

> 依然是矩阵内的搜索问题，可以考虑用深度优先搜索（DFS）或广度优先搜索（BFS）的方式进行解题。

分析问题，机器人初始位置是已知的，为`[0,0]`（矩阵左上角），那么对于解题而言可以不用考虑机器人向左、上移动的情况，仅让机器人向右、下移动即可（因为向左、上移动到达的格子必然是重复达到的格子，并不能重复计数）。

另一个问题，在移动时必然需要判断当前位置行坐标和列坐标的数位之和是否满足条件，所以可以先定义一个计算数位之和的函数。

## 数位之和计算

- 设一数字$x$，向下取整除法符号$//$，取余符号$\%$，则有：
  - $x\%10$：得到$x$的各位数字；
  - $x//10$：删除个位数字。
- 可以通过循环求得数位和`s`，代码如下：

>```python
>def sums(x):
>    s = 0
>    while x != 0:
>        s += x % 10
>        x = x // 10
>    return s
>```

## 方法一：深度优先搜索DFS

- **深度优先搜索**：可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS通过递归，先朝一个方向搜到底，再回溯至上一个节点，沿另一个方向搜索，以此类推。
- **剪枝**：在搜索中，遇到数位之和大于`k`、位置已被走过、索引越界的情况，则立即返回，称为`可行性剪枝`。

### 算法解析

- **递归参数**：当前元素在矩阵中的行列索引`i`和`j`。
- **终止条件**：1. 行列索引越界；2. 数位之和超出目标值`k`；3. 当前位置已被走过；返回0，表示不进行计数。
- **递推工作**：
  1. **标记当前坐标**：将索引`(i,j)`存入集合`available`中，表示此坐标已被访问过。
  2. **搜索下一个坐标**：沿当前坐标向下、右两个方向进行递归。
- **回溯返回值**：返回`1+下方向搜索的有效坐标总述+右方向搜索的有效坐标总述`，得到最终结果。

## 复杂度分析

> $M,N$分别为矩阵行列大小。

- 时间复杂度：$O(MN)$，最坏情况下，机器人遍历矩阵内所有单元格，此时间复杂度为$O(MN)$。
- 空间复杂度：$O(MN)$，最坏情况下，集合`available`中存储矩阵的所有坐标，使用$O(MN)$。

## 代码

```python
class Solution:
    def movingCount(self, m: int, n: int, k: int) -> int:
        def sums(x):
            s = 0
            while x != 0:
                s += x % 10
                x //= 10
            return s
        
        def dfs(i,j,k):
            if i >= m or j >= n or (sums(i)+sums(j))>k or (i,j) in available:
                return 0
            available.add((i,j))
            res =1 + dfs(i+1, j, k) + dfs(i, j+1, k)
            return res

        available = set()
        return dfs(0,0,k)
```

## 方法二：广度优先搜索BFS

- BFS/DFS：两者目标都是遍历整个矩阵，不同点在于搜索顺序不同。DFS是先朝一个方向走到底，再回退，以此类推；BFS则是按照"平推"的方式向前搜索。
- BFS实现：通常利用队列实现广度优先搜索。

### 算法解析：

- **初始化**：将机器人初始点`(0,0)`加入队列`queue`；
- **迭代终止条件**：`queue`为空代表已遍历完所有有效坐标。
- **迭代工作**：
  1. 坐标出队：将队首坐标弹出，作为当前搜索的坐标。
  2. 判断是否跳过：1. 行列索引越界；2. 数位之和超出目标值`k`；3. 当前坐标已被访问，执行`continue`。
  3. 标记当前坐标：将坐标`(i,j)`存入集合`available`中，代表已被访问。
  4. 坐标入队；将当前坐标的下方、右方的坐标加入`queue`。
- **返回值**：集合`available`的长度即为结果。

## 复杂度分析

与DFS相同

## 代码

```python
class Solution:
    def movingCount(self, m: int, n: int, k: int) -> int:
        def sums(x):
            s = 0
            while x != 0:
                s += x % 10
                x //= 10
            return s
        
        queue, visited = [(0, 0)], set()
        while queue:
            i, j= queue.pop(0)
            if i >= m or j >= n or (k < sums(i)+sums(j)) or (i, j) in visited: continue
            visited.add((i,j))
            queue.append((i + 1, j))
            queue.append((i, j + 1))
        return len(visited)
```

