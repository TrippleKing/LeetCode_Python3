剪绳子

# 题目描述

给你一根长度为`n`的绳子，请把绳子剪成整数长度的`m`段（m、n都是整数，$n>1,m>1$），每段绳子的长度记为`k[1],k[2],...,k[m]`。请问`k[1]*k[2]*...*k[m]`可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

## 示例1

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```

## 示例2

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

## 提示

- `2 <= n <= 58`

# 解题思路

> 本题使用暴力方法计算每一种切分的可能性，然后取最大值，但显然不是最优的方法。

## 方法一：动态规划

利用动态规划的思想可以帮助我们对算法进行优化。

我们记`pd[i]`代表长度为`i`的绳子可以得到的最大乘积，那么对于长度为`n`的绳子，通过迭代可以得到`pd[n]`：

- **边界条件**：`dp[0]=0,dp[1]=1,dp[2]=1`。
- **状态转移方程**：`dp[i]=max(dp[i],max((i-j)*j,j*dp[i-j]))`。`dp[i]`表示长度为`i`的绳子能得到的最大乘积，则`dp[i]`等于在绳子区间$[0,i)$之间剪开的两部分乘积最大值，如果剪开位置为$j$，则区间分为$[0,j)$和$[j,i)$两部分，第一部分长度为$j$，第二部分长度为$i-j$，而第二部分又存在剪与不剪两种情况，剪的时候值为`dp[i-j]`，不剪的时候取$(i-j)$

## 复杂度分析

- 时间复杂度：$O(N^2)$
- 空间复杂度：$O(N)$

## 代码

```python
class Solution:
    def cuttingRope(self, n: int) -> int:
        dp = [0 for _ in range(n+1)]
        dp[2] = 1
        for i in range(3, n+1):
            for j in range(1, i):
                dp[i] = max(dp[i], max((i-j)*j, j*dp[i-j]))
        return dp[n]

# 改进DP数组
# 特例处理：n < 2时，返回0；n = 2时，返回1；n = 3时，返回2
# 此时dp[1] = 1表示剪出一段长度为1的绳子，其乘积效应为1；
# 类似地有，dp[2] = 2; dp[3] = 3
# 两层for循环。外层for循环实现绳子长度的动态变化，从4变到n，即首先计算出绳子长度为4的最大乘积，再依次往下进行；
# 内层for循环实现当前绳子长度i的动态分割，i//2 + 1的目的是绳子长度为5时，剪为2和3与3和2的乘积是一样的，避免重复计算；
class Solution:
    def cuttingRope(self, n: int) -> int:
        if n < 2: return 0
        if n == 2: return 1
        if n == 3: return 2
        dp = [0] * (n+1)
        dp[1] = 1
        dp[2] = 2
        dp[3] = 3
        for i in range(4, n+1):
            for j in range(1, i//2 + 1):
                dp[i] = max(dp[i], dp[j]*dp[i-j])      
        return dp[n]


```

## 方法二：贪心思想

> 本题乍一看，不太适用贪心算法，因为每次切最大长度并不能保证最终结果为最大，例如：长度为4的绳子，切最大为3，剩下1，乘积为3，而正确切法应为$2\times2=4$。

我们可以对问题进行一定的数学推导，得到以下结论：

1. 当绳段乘积最大时，各绳段的长度必然是相近或相等的。
2. 最优的绳段长度为3。

## 数学推导

假设将长度为$n$的绳子切为$m$段：
$$
n=n_1+n_2+...+n_m
$$
本题等价于求解：
$$
\max\prod_{i=1}^{m}n_i
$$
根据"算术平均不等式"，可得：
$$
\frac{n_1+n_2+...+n_m}{m}\ge\sqrt[m]{n_1n_2...n_m}
$$
当且仅当$n_1=n_2=...=n_m$时等号成立。

>  注意：这并不是在说明将绳子等分一定能得到最大乘积（想一想把$n$长绳子分成$n$段长度为1的，最终乘积为1，显然不是理想的结果）；但上式说明了，如果希望最终取得乘积最大的结果，那么切分出的绳段长度应尽可能相同。

基于此，我们进一步假设，将绳子按照$x$长度等分为$m$段，即$n=m\times x$，则乘积为：
$$
x^m=x^{\frac{n}{x}}
$$
由于$n$总是给定的常数，只要$x^{\frac{1}{x}}$取得最大即可，我们令$y=x^{\frac{1}{x}}$，可以做以下推导：
$$
\ln y=\frac{1}{x}\ln x,两边取对数
$$

$$
\frac{1}{y}y'=\frac{1}{x^2}-\frac{1}{x^2}\ln x,对x求导
$$

$$
y'=(\frac{1}{x^2}-\frac{1}{x^2}\ln x)y=(\frac{1}{x^2}-\frac{1}{x^2}\ln x)x^{\frac{1}{x}}
$$

令$y'=0$，则$1-\ln x=0$，得到极值点$x_0=e\approx2.7$；根据以下公式，可知$x_0$为极大值点。
$$
\begin{equation}
\begin{cases}
y'>0,&x\in[-\infty,e)\\
y'<0,&x\in(e,+\infty]
\end{cases}
\end{equation}
$$
由于切分长度$x$必须为整数，最接近$e$的整数为$2$或$3$。代入式子计算：
$$
y(3)=3^{\frac{1}{3}}\approx1.44
$$

$$
y(2)=2^{\frac{1}{2}}\approx1.41
$$

> 所以应尽可能将绳子以长度为$3$进行切分。

## 切分规则

1. **最优**：3，把绳子尽可能切为多个长度为3的绳段，留下最后一段绳子的长度可能为0,1,2三种情况。
2. **次优**：2，若最后一段绳子长度为2，则保留，不再拆分为1+1.
3. **最差**：1，若最后一段绳子长度为1，则应把一份$3+1$替换为$2+2$，因为$2\times2>3\times1$。

## 算法流程

1. 当$n\le3$时，按照规则应不切分，但由于题目要求$m>1$，因此必须剪出一段长度为$1$的绳子，即返回$n-1$。
2. 当$n>3$时，求$n$除以$3$的 整数部分$a$和 余数部分$b$（即$n=3a+b$），并分为以下三种情况：
   - 当$b=0$时，直接返回$3^a$；
   - 当$b=1$时，要将一个$1+3$转换为$2+2$，因此返回$3^{a-1}\times4$；
   - 当$b=2$时，返回$3^a\times2$。

## 复杂度分析

- 时间复杂度：$O(1)$，仅有求整、求余、幂运算。
  - [求整和求余运算](https://stackoverflow.com/questions/35189851/time-complexity-of-modulo-operator-in-python)：资料提到不超过机器数的整数可以看作是$O(1)$。
  - [幂运算](https://stackoverflow.com/questions/32418731/java-math-powa-b-time-complexity)：查阅资料，浮点取幂为$O(1)$。
- 空间复杂度：$O(1)$。

## 代码

> Python 中常见有三种幂计算函数：`**`和`pow()`的时间复杂度均为$O(\log a)$；而`math.pow()`始终调用 C 库的`pow()`函数，其执行浮点取幂，时间复杂度为$O(1)$。
>

```python
class Solution:
    def cuttingRope(self, n: int) -> int:
        if n <= 3:
            return n-1
        
        a = n // 3
        b = n % 3
        if b == 1:
            return int(math.pow(3,(a-1)))*4
        if b == 2:
            return int(math.pow(3,a))*2
        return int(math.pow(3, a))
```

