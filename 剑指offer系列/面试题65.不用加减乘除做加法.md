不用加减乘除做加法

# 题目描述

写一个函数，求两个整数之和，要求在函数体内不得使用`"+", "-", "*", "/"`四则运算符号。

## 示例

```
输入: a = 1, b = 1
输出: 2
```

## 提示

- `a, b`均可能是负数或`0`
- 结果不会溢出32位整数

# 解题思路

本题考察对位运算的灵活使用，即使用位运算实现加法。

设两数字的二进制形式`a, b`，其求和` s = a + b`，`a(i)`代表`a`的二进制第`i`位，则分以下四种情况：

| `a(i)` | `b(i)` | 无进位和`n(i)` | 进位`c(i+1)` |
| :----: | :----: | :------------: | :----------: |
|   0    |   0    |       0        |      0       |
|   0    |   1    |       1        |      0       |
|   1    |   0    |       1        |      0       |
|   1    |   1    |       0        |      1       |

观察发现，**无进位和**与**异或运算**规律相同，**进位**和**与运算**规律相同（并需左移一位）。因此，无进位和`n`与进位`c`的计算如下：
$$
n = a\oplus b
$$

$$
c = a\& b << 1 
$$

和`s`等于无进位和`n`加上进位`c`，即`s = a + b --> s = n + c`

循环求`n`和`c`，直至`c = 0`，此时`s = n`，返回`n`即可

>Q：若数字`a`和`b`中存在负数，则变成了减法，如何处理？
>
>A：在计算机系统中，数值一律用**补码**来表示和存储。**补码的优势**：加法、减法可以统一处理（CPU只有加法器）。因此，以上方法**同时适用于正数和负数的加法**。

## 复杂度分析

- 时间复杂度：$O(1)$，最坏情况需循环31次
- 空间复杂度：$O(1)$

## 补充：Python负数的存储

> 由于Python的数字存储特点，需要做一些特殊处理，以下详细介绍。

Python / Java中的数字都是以**补码**形式存储的。但Python没有`int`，`long`等不同长度变量，即没有变量位数的概念。

**获取负数的补码**：需要将数字与十六进制数`0xffffffff`相与。可以理解为舍去数字`32`位以上的数字，从无线长度变为一个`32`位整数。

**返回前数字还原**：若补码`a`为负数（`0x7fffffff`是最大的正数的补码），需执行`~(a^x)`操作，将补码还原至Python的存储格式。`a^x`运算将`1`至`32`位按位取反；`~`运算将整个数字取反；因此，`~(a^x)`是将`32`位以上的位取反，即由`0`变为`1`，`1`至`32`位不变。

## 代码

```python
class Solution:
    def add(self, a: int, b: int) -> int:
        x = 0xffffffff
        a, b = a & x, b & x
        while b != 0:
            a, b = (a ^ b), (a & b) << 1 & x
        return a if a <= 0x7fffffff else ~(a ^ x)
```

