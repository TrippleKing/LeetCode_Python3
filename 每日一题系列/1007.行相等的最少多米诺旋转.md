行相等的最少多米诺旋转

# 题目描述

在一排多米诺骨牌中，`A[i]`和`B[i]`分别代表第`i`个多米诺骨牌的上半部分和下半部分。(一个多米诺是两个从1到6的数字同列平铺形成的——该平铺的每一半上都有一个数字。)

我们可以旋转第`i`张多米诺，使得`A[i]`和`B[i]`的值交换。

返回能使`A`中所有值或者`B`中所有值都相同的最小旋转次数。

如果无法做到，返回`-1`。

## 示例1

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/03/08/domino.png" alt="示例.jpg" style="zoom: 50%;" />

```
输入：A = [2,1,2,4,2,2]; B = [5,2,6,2,3,2]
输出：2
解释：结合上图，在旋转之前，A和B给出的多米诺牌。如果我们旋转第二个和第四个多米诺牌，可以使上面一行中每个值都等于2
```

## 示例2

```
输入：A = [3,5,1,2,3]; B = [3,6,3,3,4]
输出：-1
解释：在这种情况下，不可能旋转多米诺牌使任何一行的值相等。
```

## 限制

- `1 <= A[i],B[i] <= 6`
- `2 <= A.length == B.length <= 20000`

# 解题思路

对题目中所考虑的一组多米诺牌，会出现三种情况：

1. 以数字`A[0]`为基准，将`A`或`B`中的所有值都变为`A[0]`。
2. 以数字`B[0]`为基准，将`A`或`B`中所有值都变为`B[0]`。
3. 无论选择`A[0]`还是`B[0]`都没办法将`A`或`B`中的所有值都变为相同。

算法思路：

- 选择第一块多米诺牌，包含两个数字`A[0]`和`B[0]`；
- 检查其余的多米诺骨牌中是否出现过 `A[0]`。如果都出现过，则求出最少的翻转次数，其为将` A[0]` 全部翻到 `A` 和全部翻到 `B`中的较少的次数。
- 检查其余的多米诺骨牌中是否出现过 `B[0]`。如果都出现过，则求出最少的翻转次数，其为将 `B[0]` 全部翻到 `A` 和全部翻到 `B` 中的较少的次数。
- 如果上述两次检查都失败，则返回 `-1`。

## 代码

```python
class Solution:        
    def minDominoRotations(self, A: List[int], B: List[int]) -> int:
        def check(x):
            rotate_A = 0
            rotate_B = 0
            for i in range(num):
                if A[i] != x and B[i] != x:
                    return -1
                elif A[i] != x:
                    rotate_A += 1
                elif B[i] != x:
                    rotate_B += 1
            return min(rotate_A, rotate_B)
        num = len(A)
        res = check(A[0])
        if res != -1 or A[0] == B[0]:
            return res
        else:
            return check(B[0])
```

