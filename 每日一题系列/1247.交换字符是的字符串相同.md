交换字符使得字符串相同

# 题目描述

有两个长度相同的字符串`s1`和`s2`，且它们其中**只含有**字符`"x"`和`"y"`，你需要通过"交换字符"的方式使这两个字符串相同。

每次"交换字符"的时候，你都可以在两个字符串中各选一个字符进行交换。

交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换`s1[i]`和`s2[j]`，但不能交换`s1[i]`和`s1[j]`。

最后，请你返回使`s1`和`s2`相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回`-1`。

## 示例1

```
输入：s1 = "xx", s2 = "yy"
输出：1
解释：交换 s1[0] 和 s2[1]，得到 s1 = "yx"，s2 = "yx"。
```

## 示例2

```
输入：s1 = "xy", s2 = "yx"
输出：2
解释：交换 s1[0] 和 s2[0]，得到 s1 = "yy"，s2 = "xx" 。
交换 s1[0] 和 s2[1]，得到 s1 = "xy"，s2 = "xy" 。
注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 "yx"，因为我们只能交换属于两个不同字符串的字符。
```

## 示例3

```
输入：s1 = "xx", s2 = "xy"
输出：-1
```

## 示例4

```
输入：s1 = "xxyyxyxyxx", s2 = "xyyxyxxxyx"
输出：4
```

## 提示

- `1 <= s1.length,s2.length <= 1000`
- `s1, s2`只包含`x`或`y`。

# 解题思路

根据题意，可以分析出以下情况：

- `s1`与`s2`必须长度相同；
- 若`s1[i]==s2[i]`，即对应位置上字符相同，该位置显然无需交换，不影响最终结果。（因为我们需要的是最小交换次数，能不交换当然收益最大，贪心算法思想）；
- 若`s1[i]!=s2[i]`，则必然是`x-->y`或者`y-->x`这两种对应关系中的一种。

进一步分析，将`s1[i]==s2[i]`的情况隐藏掉，剩余字符的情况必然是：

- `s1`中剩余$n$个`x`和$m$个`y`，对应`s2`中剩余$n$个`y`和$m$个`x`。
- 其中，$n\ge0$，$m\ge0$。

结合示例1、示例2、示例3，可以得到以下分析：

- `xx-->yy`只需一次交换；`xy-->yx`只需两次交换；仅`x-->y`无法实现；
- 对于`s1`中的$n$个`x`与$m$个`y`，满足以下关系即可：
  1. 若`abs(n-m)%2 != 0`，则无法实现，返回-1
  2. 否则，返回`n//2+n%2+m//2+m%2`。

## 复杂度分析

- 时间复杂度：$O(N)$，仅对`s1`遍历一次即可。
- 空间复杂度：$O(1)$。

## 代码

```python
class Solution:
    def minimumSwap(self, s1: str, s2: str) -> int:
        num_s1 = len(s1)
        num_s2 = len(s2)
        num_x = 0
        num_y = 0
        if num_s1 != num_s2:
            return -1
        for i in range(num_s1):
            if s1[i] == s2[i]:
                continue
            else:
                if s1[i] == 'x':
                    num_x += 1
                else:
                    num_y += 1
        tmp = abs(num_x - num_y)
        if tmp % 2 != 0:
            return -1
        
        return (num_x//2)+(num_x % 2) + (num_y//2)+(num_y % 2)


```



