做菜顺序

# 题目描述

一个厨师收集了他`n`道菜的满意程度`satisfaction`，这个厨师做出每道菜的时间都是`1`单位时间。

一道菜的**"喜爱时间"系数**定义为烹饪这道菜以及之前每道菜所花费的时间乘以这道菜的满意程度，也就是`time[i]*satisfaction[i]`。

请你返回做完所有菜的"喜爱时间"总和的最大值为多少。

你可以按**任意**顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。

## 示例1

```
输入：satisfaction = [-1,-8,0,5,-9]
输出：14
解释：去掉第二道和最后一道菜，最大的喜爱时间系数和为 (-1*1 + 0*2 + 5*3 = 14) 。每道菜都需要花费 1 单位时间完成。
```

## 示例2

```
输入：satisfaction = [4,3,2]
输出：20
解释：按照原来顺序相反的时间做菜 (2*1 + 3*2 + 4*3 = 20)
```

## 示例3

```
输入：satisfaction = [-1,-4,-5]
输出：0
解释：大家都不喜欢这些菜，所以不做任何菜可以获得最大的喜爱时间系数。
```

## 示例4

```
输入：satisfaction = [-2,5,-1,0,3,-3]
输出：35
```

## 提示

- `n == satisfaction.length`
- `1 <= n <= 500`
- `-10^3 <= satisfaction[i] <= 10^3`

# 解题思路

## 方法一：贪心算法

我们先考虑一个最简单的情况，假设至多只能选择做一道菜，该如何选择？毫无疑问，选择满意程度最大的那道菜，记为$s_0$，并且需要保证$s_0>0$，若$s_0\le0$，我们将一道菜都不做。

接着，我们可以至多选两道菜，那么显然选择最优的$s_0$，同时再选择次优的$s_1$，且先做$s_1$，再做$s_2$。则满意度总和为$s_1+2s_0$，且需要保证$s_1+2s_0>s_0$，即$s_1+s_0>0$，这样我们才能选择$s_1$。

同理，如果可以至多选择三道菜，则需要保证$s_2+2s_1+3s_0>s_1+2s_0$，即$s_2+s_1+s_0>0$，这样我们才能选择$s_2$。

因此我们就有了一个贪心的大致思路：

- 将所有菜的满意程度从大到小排序；
- 按照排好序的顺序依次遍历这些菜，对于当前遍历到的菜$s_i$，如果它与之前选择的所有菜的满意程度之和大于`0`，就选择做这道菜，否则可以直接退出遍历的循环。这是因为如果$s_i$与之前选择的所有菜的满意程度之和已经小于等于`0`了，那么后面的菜比$s_i$能贡献的满意程度还要小，就更不可能得到一个大于`0`的和了。

## 复杂度分析

- 时间复杂度：$O(N\log N)$，排序花费$O(N\log N)$的时间复杂度；遍历花费$O(N)$
- 空间复杂度：$O(\log N)$，使用语言自带的排序，空间复杂度为$O(\log N)$，如果使用堆排序，空间复杂度可以降低至$O(1)$。

## 代码

```python
class Solution:
    def maxSatisfaction(self, satisfaction: List[int]) -> int:
        satisfaction = sorted(satisfaction, reverse = True)

        presum = 0
        res = 0
        for i in satisfaction:
            if i + presum > 0:
                presum += i
                res += presum
        
        return res 
```

## 方法二：动态规划

把该问题看作是一个`0-1`背包问题，利用动态规划的思想进行求解。

建立一个二维数组`dp`，`dp[i][j]`表示前`i`个菜中，选中`j`个菜所能达到的最大值。

我们可以根据第`i`个菜做与不做，对`dp[i][j]`进行更新：

- 如果选择做第`i`个菜，则`dp[i][j] = dp[i-1][j-1]+satisfaction[i-1]*j`；
- 如果不选择做第`i`个菜，则`dp[i][j] = dp[i-1][j]`；

`dp[i][j]`取上述两种更新方式的最大值。

特殊地，对于`i = j`的情况，第`i`个菜必须要做；对于`i = 0 or j = 0`，的情况，`dp[i][j]`均为`0`。

最终返回`dp`数组中的最大元素即可。

## 复杂度分析

- 时间复杂度：$O(N^2)$
- 空间复杂度：$O(N^2)$

## 代码

```python
class Solution:
    def maxSatisfaction(self, satisfaction: List[int]) -> int:
        satisfaction = sorted(satisfaction)
        n = len(satisfaction)
        dp = [[0 for _ in range(n+1)] for _ in range(n+1)]
        for i in range(1, n+1):
            for j in range(1, n+1):
                if i == j:
                    dp[i][j] = dp[i-1][j-1] + satisfaction[i-1]*j
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]+satisfaction[i-1]*j)
        return max(max(dp))
```

