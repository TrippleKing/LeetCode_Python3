分汤

# 题目描述

有`A`和`B`两种类型的汤。一开始每种类型的汤有`N`毫升。有四种分配操作：

- 提供`100ml`的汤`A`和`0ml`的汤`B`；
- 提供`75ml`的汤`A`和`25ml`的汤`B`；
- 提供`50ml`的汤`A`和`50ml`的汤`B`；
- 提供`25ml`的汤`A`和`75ml`的汤`B`；

当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为`0.25`的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当每种类型的汤都分配完时，停止操作。

注意不存在先分配`100ml`汤`B`的操作。

需要返回的值：汤`A`先分配完的概率 + 汤`A`和汤`B`同时分配完的概率 / 2

## 示例

```
示例:
输入: N = 50
输出: 0.625
解释:
如果我们选择前两个操作，A将首先变为空。对于第三个操作，A和B会同时变为空。对于第四个操作，B将首先变为空。
所以A变为空的总概率加上A和B同时变为空的概率的一半是 0.25 *(1 + 1 + 0.5 + 0)= 0.625。
```

## 提示

- `0 <= N <= 10^9`
- 返回值在`10^-6`的范围内被认为是正确的。

# 解题思路

**动态规划思想**：

首先，由于四种分配操作都是`25`的倍数，我们可以将`N`除以`25`（如果有余数，则补`1`），相应的分配操作将变为`(4, 0), (3, 1), (2, 2), (1, 3)`。

当`N`较小时，我们可以用动态规划来解决这个问题，设`dp[i][j]`表示汤`A`和汤`B`分别剩下`i`和`j`份时，所求的概率。状态转移方程为：

`dp[i][j] = 0.25 * (dp[i-4][j] + dp[i-3][j-1] + dp[i-2][j-2] + dp[i-1][j-3])`

边界条件为：

```python
if i <= 0 and j <= 0: dp[i][j] = 0.5 # 同时分配完
if i <= 0 and j > 0: dp[i][j] = 1.0 # A先分配完
if i > 0 and j <= 0: dp[i][j] = 0.0 # B先分配完
```

这个动态规划的时间复杂度为$O(N^2)$，即使将$N$除以`25`，可以降低$N$的大小，但当$N$很大时，仍然无法在短时间内得到答案，因此我们需要进一步分析。可以发现，分配的操作有`(4, 0), (3, 1), (2, 2), (1, 3)`四种，在每一回合，分配汤`A`的期望为`(4 + 3 + 2 + 1)/4 = 2.5`份，分配汤`B`的期望为`(0 + 1 + 2 + 3)/4 = 1.5`份，初始时均为`N`，则当$N$很大时，汤`A`会有很大的概率比汤`B`先分配完，所以概率应该非常接近`1`。事实上，当`N >= 500 * 25`时，所求概率已经大于`0.999999`了（可以通过上面的动态规划方法求出），它和`1`的误差（无论是绝对误差还是相对误差）都小于`10^-6`。因此在`N >= 500 * 25`时，直接返回`1`即可。

## 复杂度分析

- 时间复杂度：$O(N^2)$，$N < 500\times 25$；当$N >= 500\times 25$时，为$O(1)$。
- 空间复杂度：$O(N^2)$，$N < 500\times 25$；当$N >= 500\times 25$时，为$O(1)$。

## 代码

```python
class Solution:
    def soupServings(self, N: int) -> float:
        if not N:
            return 0.5

        if not N % 25:
            N = N // 25
        else:
            N = N // 25 + 1
        
        if N >= 500:
            return 1

        dp = [[0.0 for _ in range(N+1)] for _ in range(N+1)]
        for i in range(1, N+1):
            for j in range(1, N+1):
                for ii, jj in [(i-4, j), (i-3, j-1), (i-2, j-2), (i-1, j-3)]:
                    if ii > 0 and jj > 0:
                        dp[i][j] += dp[ii][jj]
                    elif ii <= 0:
                        dp[i][j] += 0.5 if jj <= 0 else 1.0
                dp[i][j] *= 0.25
        return dp[-1][-1]
```

