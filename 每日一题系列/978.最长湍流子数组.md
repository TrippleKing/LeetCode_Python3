最长湍流子数组

# 题目描述

当`A`的子数组`A[i], A[i+1], ..., A[j]`满足下列条件时，我们称其为湍流子数组：

- 若`i <= k < j`，当`k`为奇数时，`A[k] > A[k+1]`，且当`k`为偶数时，`A[k] < A[k+1]`；
- **或**若`i <= k < j`，当`k`为偶数时，`A[k] > A[k+1]`，且当`k`为奇数时，`A[k] < A[k+1]`；

也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。

返回`A`的最大湍流子数组的**长度**。

## 示例1

```
输入：[9,4,2,10,7,8,8,1,9]
输出：5
解释：(A[1] > A[2] < A[3] > A[4] < A[5])
```

## 示例2

```
输入：[4,8,12,16]
输出：2
```

## 示例3

```
输入：[100]
输出：1
```

## 提示

- `1 <= A.length <= 40000`
- `0 <= [i] <= 10^9`

# 解题思路

首先来理解一下题目的意思，我们把数组中`A[i+1] > A[i]`称为**上升流**，把`A[i+1] < A[i]`称为**下降流**，`A[i+1] = A[i]`称为**水平流**。那么我们要找的是一段交替上升下降的子数组。例如示例1输入`[9,4,2,10,7,8,8,1,9]`，就可以表示成如下图所示的意思：

![示例.jpg](http://xyao-imgs.oss-cn-beijing.aliyuncs.com/img/85bd024ca1de1c4a6953b552b3868085c9243a8ba8fddab344d4064ce905f368.jpg)

**算法流程**：

- **特例处理**：若`A`的长度为`1`，则直接返回`1`；若`max(A) == min(A)`，表示`A`中全部数字都相同，也直接返回`1`。
- **初始化**：初始化`dp`数组，长度为`A`的长度，初始值都为`0`
- **状态表示**：`dp[i]`表示以`A[i]`为结尾的最长湍流子数组的长度
- **状态转移**：`dp[0] = 1`，以`A[0]`为结尾自然就`1`个数字，很好理解；观察上图所示的示例，可以发现对于第`i`个数字，如果它比两边数字都大**或者**比两边数字都小，那么第`i`个数字就可以加入到湍流子数组中，即有`dp[i] = dp[i-1] + 1`；否则`dp[i] = 1`
- **返回值**：`max(dp) + 1`。这里为什么要`+1`呢？解释如下：
  - 因为有对比存在某个**中间数字**不满足条件，但是中间数字的前一个条件满足，那么`+1`就表示把中间数字加上去。
  - 如果全部都满足条件，但是最后一个数字是没有对比的，所以如果最后一个数字的前面一个数字满足，同样要`+1`，才能得到正确答案。

## 复杂度分析

- 时间复杂度：$O(N)$
- 空间复杂度：$O(N)$

## 代码

```python
class Solution:
    def maxTurbulenceSize(self, A: List[int]) -> int:
        if len(A) == 1: return 1

        if max(A) == min(A): return 1

        dp = [0 for _ in range(len(A))]
        dp[0] = 1
        for i in range(1, len(A) - 1):
            if A[i-1] < A[i] and A[i] > A[i+1]:
                dp[i] = dp[i-1] + 1
            elif A[i-1] > A[i] and A[i] < A[i+1]:
                dp[i] = dp[i-1] + 1
            else:
                dp[i] = 1
        return max(dp) + 1
```

