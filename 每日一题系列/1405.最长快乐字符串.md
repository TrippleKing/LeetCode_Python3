最长快乐字符串

# 题目描述

如果字符串不含有任何`aaa`，`bbb`或`ccc`这样的字符串作为子串，那么该字符串就是一个"快乐字符串"。

给你三个整数`a`，`b`，`c`请你返回**任意一个**满足下列全部条件的字符串`s`：

- `s`是一个尽可能长的快乐字符串。
- `s`中**最多**有`a`个字母`"a"`、`b`个字母`"b"`、`c`个字母`"c"`。
- `s`中只含有`"a"`、`"b"`、`"c"`三种字母。

如果不存在这样的字符串`s`，请返回空字符串`""`。

## 示例1

```
输入：a = 1, b = 1, c = 7
输出："ccaccbcc"
解释："ccbccacc" 也是一种正确答案。
```

## 示例2

```
输入：a = 2, b = 2, c = 1
输出："aabbc"
```

## 示例3

```
输入：a = 7, b = 1, c = 0
输出："aabaa"
解释：这是该测试用例的唯一正确答案。
```

## 提示

- `0 <= a,b <= 100`
- `a + b + c > 0`

# 解题思路

> 本题也是用贪心思路求解的一道题。

算法的思路其实很简单，具体的实现方式也可以多种多样。在往字符串`s`添加字母时，优先添加当前字母库中数量最多的字母，若添加数量最多的字母会导致出现`aaa`、`bbb`或`ccc`的情况，则改为添加次多的字母，依此循环。

此外，字母`"a"`、`"b"`、`"c"`的数量存在相互牵制的关系，例如，假设有$a>b>c$，则能够在字符串`s`中出现字母`"a"`的最大数量为$2\times(b+c)$。

由此，我们可以在初始化字母数量时，进行一定的修正。

## 复杂度分析

- 时间复杂度：$O(N)$
- 空间复杂度：$O(N)$

## 代码

```python
class Solution:
    def longestDiverseString(self, a: int, b: int, c: int) -> str:
        # 更新初始存量，根据插空规则修正单个字符最大可能的数量
        d = {'a':min(a,2*(b+c+1)),'b':min(b,2*(a+c+1)),'c':min(c,2*(b+a+1))}
        # 修正后的数量确保可以全部用在结果中，求和计算字符串总长
        n = sum(d.values())
        # 维护结果列表
        res = []
        # 单次插入一个字符，根据长度循环
        for _ in range(n):
            # 候选的字母
            cand = set(['a','b','c'])
            # 如果列表最后两个字符相同，根据规则不能插入连续三个，故将该字符从候选中删除
            if len(res)>1 and res[-1]==res[-2]:
                cand.remove(res[-1])
            # 贪心，在候选中选择存量最大的字符
            tmp = max(cand,key=lambda x:d[x])
            # 将它加到结果里
            res.append(tmp)
            # 把它的剩余计数减去1. 开始下一轮
            d[tmp] -= 1
        return ''.join(res)

```

