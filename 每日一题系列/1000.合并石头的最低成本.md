合并石头的最低成本

# 题目描述

有`N`堆石头排成一排，第`i`堆中有`stones[i]`块石头。

每次移动需要将**连续的**`K`堆石头合并为一堆，而这个移动的成本为这`K`堆石头的总数。

找出把所有石头合并成一堆的最低成本。如果不可能，返回`-1`。

## 示例1

```
输入：stones = [3,2,4,1], K = 2
输出：20
解释：
从 [3, 2, 4, 1] 开始。
合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。
合并 [4, 1]，成本为 5，剩下 [5, 5]。
合并 [5, 5]，成本为 10，剩下 [10]。
总成本 20，这是可能的最小值。
```

## 示例2

```
输入：stones = [3,2,4,1], K = 3
输出：-1
解释：任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。
```

## 示例3

```
输入：stones = [3,5,1,2,6], K = 3
输出：25
解释：
从 [3, 5, 1, 2, 6] 开始。
合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。
合并 [3, 8, 6]，成本为 17，剩下 [17]。
总成本 25，这是可能的最小值。
```

## 提示

- `1 <= stones.length <= 30`
- `2 <= K <= 30`
- `1 <= stones[i] <= 100`

# 解题思路

首先，该题有着较明显的区间关联（相邻的K堆合成一堆），可以初步判定为**区间DP**。

对**区间DP**这个概念不清楚的小伙伴，可以上B站找找相关视频，这里推荐一个[西北工业大学ACM2017暑假集训-区间DP](https://www.bilibili.com/video/BV1Qx411q7bz?from=search&seid=17410535217395696530)视频。

我们将`dp[i][j]`定义为在区间`[j, i]`上合并到合并不了的时候的最低成本（即使这个区间最终不能合并为1堆石子，也应计算最低成本和）。

于是，状态转移方程由以下分析得出：

- `len1`为区间`[j, i]`最后一次合并时的第一个区间的长度，`len2`为其余区间的长度。由于是区间`[j, i]`上的最后一次合并，所以第一个区间一定合并成1堆；第二个区间合并到不能合并时，最大可能的石堆数为`K-1`。
- 于是有，`[第一个区间合并完剩下的石堆数] + [其余区间合并完剩下的石堆数] <= K`。
- 如果`[第一个区间合并完剩下的石堆数] + [其余区间合并完剩下的石堆数] = K`，即可以继续合并成1堆，则`dp[i][j] = min(dp[i][j], dp[t][j] + dp[i][t+1] + sum(stones[j:i+1])) `
- 如果不能继续合并了，即`[第一个区间合并完剩下的石堆数] + [其余区间合并完剩下的石堆数] < K`，则`dp[i][j] = min(dp[i][j], dp[t][j] + dp[i][t+1])`

## 代码

```python
class Solution:
    def mergeStones(self, stones: list, K: int) -> int:
        N = len(stones)
        if N == 1:
            return 0
        #由于每次石堆合并操作，都会减少K-1堆石头，所以N除以K-1不余1的，一定需要返回-1
        if (N-1)%(K-1) != 0:
            return -1
        
        #dp[i][j]是指区间[j, i]上合并到合并不了了时候的成本和
        dp = [[float('inf')] * N for _ in range(N)]

        for i in range(N):
            dp[i][i] = 0
        for i in range(N):
            for j in range(i-1, -1, -1):
                if i == j+K-1:
                    dp[i][j] = sum(stones[j:i+1])
                    continue
                for t in range(j, i, K-1):
                    tmp = (i-t-1)%(K-1)+2
                    if tmp == K:
                        dp[i][j] = min(dp[i][j], dp[t][j] + dp[i][t+1] + sum(stones[j:i+1]))
                    elif tmp < K:
                        dp[i][j] = min(dp[i][j], dp[t][j] + dp[i][t+1])
        return dp[-1][0]
```

