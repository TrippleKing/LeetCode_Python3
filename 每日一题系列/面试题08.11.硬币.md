硬币

# 题目描述

给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。（结果可能会很大，你需要将结果模上1000000007）

## 示例1

```
输入: n = 5
输出：2
解释: 有两种方式可以凑成总金额:
5=5
5=1+1+1+1+1
```

## 示例2

```
输入: n = 10
输出：4
解释: 有四种方式可以凑成总金额:
10=10
10=5+5
10=5+1+1+1+1+1
10=1+1+1+1+1+1+1+1+1+1
```

## 说明

- `0 <= n（总金额） <= 1000000`

# 解题思路

> 这是一道典型的考察动态规划的题目。（当然，其实也可以用数学的方法解）

## 方法一：动态规划

首先考虑一个朴素的方法，用$dp(i, v)$来表示前$i$种面值的硬币构成面值为$v$的方案数量，用$c_i$来表示第$i$种面值的硬币的面值。

我们可以从$dp(i-1,v-0\times c_i),dp(i-1,v-1\times c_i),...,dp(i-1,v-k\times c_i)$转移得到$dp(i, v)$。它们表示第$i$个面值的硬币选$0,1,2,...,k$个的时候，构成面值为$v$的方案数量，其中$k$为满足$v-k\times c_i\ge 0$的最大整数。于是我们可以推导出如下的动态规划转移方程：
$$
dp(i,v)=\sum\limits_{j=0}^{k}dp(i-1,v-j\times c_i),k=\lfloor \frac{v}{c_i}\rfloor
$$
这个方程表示前$i$种硬币，构成面值$v$的方案数量由前$i-1$种面值构成的一些面值的方案数量决定。我们可以考虑$c_i$取多少个，$c_i$可以取$0$个、$1$个、......最大可以取$\lfloor\frac{v}{c_i}\rfloor$个，那么前$i$种硬币，构成面值$v$的方案数量就是如下各项的累加：前$i-1$种硬币构成面值$v$的方案数量（表示不取$c_i$），前$i-1$种硬币构成面值$v-c_i$的方案数量（表示取1个$c_i$），......，前$i-1$种硬币构成面值$v-\lfloor\frac{v}{c_i}\rfloor\times c_i$的方案数量（表示取$\lfloor\frac{v}{c_i}\rfloor$个$c_i$）。

**方案优化**：

- **考虑优化时间复杂度**：我们把转移方程求和式展开：

  - $$
    dp(i,v)=dp(i-1,v)+dp(i-1,v-c_i)+...+dp(i-1,v-k\times c_i)
    $$

  - 共$k+1$项，其中$k=\lfloor\frac{v}{c_i}\rfloor$。

- 我们用$v-c_i$替换$v$，可以得到如下式子：

  - $$
    dp(i,v-c_i)=dp(i-1,v-c_i)+dp(i-1,v-2\times c_i)+...+dp(i-1,v-k\times c_i)
    $$

  - 共$k$项，且与上式中的后$k$项完全相同。

- 于是，我们可以用$dp(i,v-c_i)$代替$k$项，将转移方程转换为如下式子：

  - $$
    dp(i,v)=dp(i-1,v)+dp(i,v-c_i)
    $$

- **考虑优化空间复杂度**：

- 根据最原始的转移方程，我们需要一个二维数组。但是观察转换后的转移方程：

  - $$
    dp(i,v)=dp(i-1,v)+dp(i,v-c_i)
    $$

  - 在更新$dp(i,v)$时，只与$dp(i-1,v)$和$dp(i,v-c_i)$有关，不用关心$\lbrack0,i-2\rbrack$。

- 于是，我们可以用"滚动数组"的思想来优化这个过程，实现方式如下：

  - 用一个一维数组来实现转移：用`n+1`维的数组`dp[]`来表示，在第$i$轮计算时，第$i-1$轮的答案保存在`dp`数组中，`dp[v]`保存的是`dp(i-1,v)`的值，在第$i$轮计算结束后，它将保存`dp(i,v)`的值。因为$dp(i,v)$只与$dp(i-1,v)$和$dp(i,v-c_i)$相关，在计算$dp(i,v)$但还未更新`dp[v]`时，`dp[v]`保存的是`dp(i-1,v)`，而`dp[0...v-1]`中保存的是第$i$轮更新后的值，$dp(i,v-c_i)$必然被包含在其中。

## 复杂度分析

> 其实上面都已经分析过了。

- 时间复杂度：$O(N)$
- 空间复杂度：$O(N)$

## 代码

```python
class Solution:
    def waysToChange(self, n: int) -> int:
        mod = 10**9 + 7
        dp = [0] * (n + 1)
        dp[0] = 1
        coins = [25, 10, 5, 1]
        for coin in coins:
            for i in range(coin, n+1):
                dp[i] += dp[i - coin]
        return dp[n] % mod
```

## 方法二：纯数学推导

对于给定的$n$，先假设使用$25$分的硬币的个数为$i$，则剩下的部分记为$r=n-25\times i$，$r$可以表示成：
$$
r=10\times a+5\times b + c
$$
其中，$a$能取的最大值记为$a_0=\lfloor\frac{r}{10}\rfloor$，当$a=a_0$时，限定$c<5$可以得到最大的$b$值，记为$b_0$，那么可以得到$c_0=r-10\times a_0-5\times b_0$。

再假设选择$x$个10分硬币，那么还剩下的金额表示为：
$$
10\times(a_0-x)+5\times b_0+c_0
$$
考虑把$10\times(a_0-x)$这一项全部用$5$分硬币来替代，则有：
$$
5\times(2\times a_0-2\times x+b_0)+c_0
$$
那么$5$分硬币可以选择的范围是$\lbrack0,2\times a_0-2\times x+b_0\rbrack$，剩下的用$1$分硬币补齐。

即对于$25$分取$i$个，$10$分取$x$个的时候方案总数为$2\times a_0-2\times x+b_0+1$，根据等差数列求和的方法，对$x$求和：
$$
\sum\limits_{x=0}^{a_0}(2a_0-2x+b_0+1)=(a_0+1)(a_0+b_0+1)
$$
再枚举$i$并累加即可得到最终答案。

## 复杂度分析

- 时间复杂度：$O(N)$
- 空间复杂度：$O(1)$

## 代码

```python
class Solution:
    def waysToChange(self, n: int) -> int:
        mod = 10**9 + 7
        ans = 0
        for i in range(n // 25 + 1):
            rest = n - i * 25
            a, b = rest // 10, rest % 10 // 5
            ans += (a + 1) * (a + b + 1)
        return ans % mod
```

