骑士拨号器

# 题目描述

国际象棋中的骑士可以按下图所示进行移动：

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/11/03/knight.png" alt="骑士移动_1_.jpg" style="zoom:67%;" />

这一次，我们将"骑士"放在电话拨号盘的任意数字键（如下图所示）上，接下来，骑士将会跳`N - 1`步。每一步必须是从一个数字键跳到另一个数字键。

![数字键.jpg](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/11/03/keypad.png)

每当它落在一个键上（包括骑士的初始位置），都会拨出键对应的数字，总共按下`N`位数字。

你能用这种方式拨出多少个不同的号码？

因为答案可能很大，**所以输出答案取模**`10^9 + 7`。

## 示例1

```
输入：1
输出：10
```

## 示例2

```
输入：2
输出：20
```

## 示例3

```
输入：3
输出：46
```

## 提示

- `1 <= N <= 5000`

# 解题思路

观察"骑士"的移动规律，并将其与数字键结合，可以得到以下规律：

- 对于数字`1`，下一步仅可能跳到数字`6`或数字`8`；
- 对于数字`2`，下一步仅可能跳到数字`7`或数字`9`；
- 对于数字`3`，下一步仅可能跳到数字`4`或数字`8`；
- 对于数字`4`，下一步仅可能跳到数字`0`或数字`3`或数字`9`；
- 对于数字`5`，没有下一步数字可选；
- 对于数字`6`，下一步仅可能跳到数字`0`或数字`1`或数字`7`；
- 对于数字`7`，下一步仅可能跳到数字`2`或数字`6`；
- 对于数字`8`，下一步仅可能跳到数字`1`或数字`3`；
- 对于数字`9`，下一步仅可能跳到数字`2`或数字`4`；
- 对于数字`0`，下一步仅可能跳到数字`4`或数字`6`；

可以发现数字`5`比较特殊，"骑士"一旦走到数字`5`就会被**困住**，无法继续移动，而其他数字也不会走到数字`5`。所以当且仅当`N = 1`时，数字`5`可以出现；否则不会出现走到数字`5`的情况。

我们用`dp(start, n)`表示骑士从数字`start`开始，跳了`n-1`步得到不同的`n`位数字的个数。`dp(start, n)`可以从`dp(x, n-1)`转移而来，其中`x`是任意一个可以一步跳到`start`的数字。例如当`start = 1`时，`x`可以从`6`或`8`，因此有`dp(1, n) = dp(6, n-1) + dp(8, n-1)`。

最终的答案即为`dp(0, N) + dp(1, N) + ... + dp(9, N)`。我们可以使用**滚动数组**减少空间复杂度，这是因为`dp(start, n)`只和`dp(x n-1)`有关，因此在计算`dp(start, n)`时，所有第二维小于`n-1`的`dp`值都不必存储。

## 复杂度分析

- 时间复杂度：$O(N)$
- 空间复杂度：$O(1)$，也可以看成$O(10)$。

## 代码

```python
class Solution:
    def knightDialer(self, N: int) -> int:
        moves = [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], 
                 [],
                 [0, 1, 7], [2, 6], [1, 3], [2, 4]]
        mod = 10**9 + 7
        dp1 = [1] * 10
        for i in range(N - 1):
            dp2 = [0] * 10
            for idx, ele in enumerate(dp1):
                for nei in moves[idx]:
                    dp2[nei] += ele
                    dp2[nei] %= mod       
            dp1 = dp2
        return sum(dp1) % mod
```

## 优化

在`N >= 2`时，除数字`5`以外的`9`个数字都是可到达的。

每跳一步，数字的变化如图所示：

<img src="https://pic.leetcode-cn.com/7eaa506cae552733d5dc771c92d943a122e30eeef648460d6e3ec81fccfe76d8-QQ%E6%88%AA%E5%9B%BE20200226000022.png" alt="数字变化.jpg" style="zoom:67%;" />

图片表示，当骑士处于`1`处时，下一步可以在`6`或`8`；骑士处于`4`处时，下一步将在`3`或`0`或`9`；......

我们可以发现，`1, 3, 7, 9`处于对称位置；`2, 8`处于对称位置；`4, 6`处于对称位置。因此，我们可以将数字分为4个状态，命名为`A, B, C, D`。其中`A:{1, 3, 7, 9}, B:{2, 8}, C:{4, 6}, D:{0}`。

我们用`dp(x, n)`表示：在状态`x`下，跳跃`n`步能够得到不同数字的个数，则状态转移方程为：

```
dp(A, n) = dp(B, n-1) + dp(C, n-1)
dp(B, n) = 2 * dp(A, n-1)
dp(C, n) = 2 * dp(A, n-1) + dp(D, n-1)
dp(D, n) = 2 * dp(C, n-1)
```

解释为：

处于状态`A`中的数字`(1, 3, 7, 9)`通过一次跳跃要么变成状态`B(2, 8)`，要么变成状态`C(4, 6)`

处于状态`B`中的数字`(2, 8)`通过一次跳跃有两种方式变成状态`A(1, 3, 7, 9)`

处于状态`C`中的数字`(4, 6)`通过一次跳跃有两种方式变成状态`A(1, 3, 7, 9)`，还有一种方式变成状态`D(0)`

处于状态`D`中的数字`(0)`通过一次跳跃有两种方式变成状态`C(4, 6)`

## 复杂度分析

- 时间复杂度：$O(N)$
- 空间复杂度：$O(1)$

## 代码

```python
class Solution:
    def knightDialer(self, N: int) -> int:
        if N==1: return 10
        #分别为状态A,B,C,D
        nums=[1,1,1,1]
        for _ in range(N-1):
            nums=[nums[1]+nums[2], 2*nums[0], 2*nums[0]+nums[3], 2*nums[2]]
        #状态A有4个数字，B有2个数字，C有2个数字，D有1个数字
        return (4*nums[0]+2*nums[1]+2*nums[2]+nums[3])%1000000007
```

