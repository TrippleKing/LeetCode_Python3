非递增顺序的最小子序列

# 题目描述

给你一个数组`nums`，请你从中抽取一个子序列，满足该子序列的元素之和**严格**大于未包含在该子序列中的各元素之和。

如果存在多个解决方案，只需返回**长度最小**的子序列。如果仍然有多个解决方案，则返回**元素之和最大**的子序列。

与子数组不同的地方在于，`数组的子序列`**不强调**元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。

**注意**，题目数据保证满足所有约束条件的解决方案是**唯一**的，返回的答案应当按**非递增顺序**排列。

## 示例1

```
输入：nums = [4,3,10,9,8]
输出：[10,9]
解释：子序列[10,9]和[10,8]是长度最小的，满足元素之和大于其他各元素之和。但是[10,9]的元素之和比[10,8]大。
```

## 示例2

```
输入：nums = [4,4,7,6,7]
输出：[7,7,6]
解释：子序列[7,7]的和为14，不严格大于剩下的其他元素之和(14=4+4+6)。因此，[7,7,6]是满足题意的最小子序列。注意，元素按非递增顺序返回。
```

## 示例3

```
输入：nums = [6]
输出：[6]
```

## 提示

- `1 <= nums.length <= 500`
- `1 <= nums[i] <= 100`

# 解题思路

## 优先过滤

根据题目内容以及提示，可以对输入数据进行适当过滤。

- 当`nums`长度为1时，可以直接返回`nums`，无需其他任何操作。

- 当然还可以考虑一下，当`nums`长度为2时，直接返回`max(nums)`。

要不再顺手考虑一下`nums`长度为3的时候？开个玩笑，毕竟上述情况是少数，我们的算法是要解决更一般的情况。

`优先过滤`可以作为一种锦上添花的手段，有时候从特殊情况中或许就发现了一般现象。

## 算法思路

根据题意，我们最终应该从数组`nums`中得到两部分序列：一部分是最终输出结果`result`；另一部分是剩余部分`rest`。要求`sum(result)>sum(rest)`，转换一下其实就相当于要求`sum(result)>(sum(nums)//2)`。

那么我们的思路就出来的：

1. 先将`nums`进行升序排序（sorted一下或者自己写，都行）。
2. 然后从排序后的`nums`中取出末尾元素，放入`result`中，判断`sum(result)>(sum(nums)//2)`是否成立。
3. 如果判断成立，则返回`result`；否则重复第二步

因为事先已经对`nums`进行排序，所以每一次取出的元素一定是当前`nums`中的最大值，而放入`result`中也必然是非递增顺序。（完美契合题目要求）

## 复杂度分析

- 时间复杂度：$O(nlogn)$，主要是对`nums`排序比较花费时间。
- 空间复杂度：$O(n)$。

## 代码

```python
class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        if len(nums) == 1:
            return nums
        nums = sorted(nums)
        res = []
        half_num = sum(nums) // 2
        for _ in range(len(nums)):
            max_num = nums.pop()
            res.append(max_num)
            if sum(res) > half_num:
                return res
```



