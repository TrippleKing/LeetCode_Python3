二叉搜索树序列

# 题目描述

从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。给定一个由不同节点组成的二叉树，输出所有可能生成此树的数组。

## 示例

给定如下二叉树

```
        2
       / \
      1   3
```

返回：

```
[
   [2,1,3],
   [2,3,1]
]
```

# 解题思路

## 补充知识

先明确什么是二叉搜索树？

**二叉搜索树**（又称：二叉查找树、二叉排序树）：它或者是一棵空树，或者是一棵具有以下性质的二叉树：若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也均为一棵二叉搜索树。

## 题目分析

首先从最简单的示例看看：

```
        2
       / \
      1   3
```

返回：

```
[
   [2,1,3],
   [2,3,1]
]
```

由于是从数组中从左到右插入元素到二叉搜索树中，因此每个元素在已存在的二叉搜索树中的插入位置都是确定的。

可以得出以下结论：

- **数组的第一个元素，必定对应于二叉搜索树的根节点**；
- **一个节点对应的子节点在序列上必定在父节点元素之后**；
- **输出序列中可以先出现右节点再出现左节点**。

看一个复杂一点的例子：

```
        2
       / \
      1   4
         /
        3
```

返回：

```
[
   [2,1,4,3],
   [2,4,1,3],
   [2,4,3,1]
]
```

输出序列不仅仅在于子树的插入顺序不同，如上述结果中，`4 -> 1`右子树`4`后面可以先跟左子树`1`，再接`3`。但是可以确定的是，节点`3`无论如何不会直接出现在根节点`2`后面。

即，**序列中子树节点的相对顺序是可以确定的**，我们将子树中的节点看作单个序列，如上述例子中左边序列为`{1}`，右边序列为`{4, 3}`，将两个序列按照相对顺序进行混合：

```
[
   [1,4,3],
   [4,1,3],
   [4,3,1]
]
```

再在各序列中加入根节点`2`，恰好对应了答案。

## 代码

```python
class Solution:
    def BSTSequences(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return [[]]
        
        res = []
        
        def recur(root, q, path):
            if root.left:
                q.append(root.left)
            if root.right:
                q.append(root.right)
            if not q:
                res.append(path)
                return 
            
            for i, next_node in enumerate(q):
                new_queue = q[:i] + q[i+1:]
                recur(next_node, new_queue, path+[next_node.val])
        
        recur(root, [], [root.val])
        return res
```

