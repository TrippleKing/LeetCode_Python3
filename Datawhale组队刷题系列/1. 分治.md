# 分治

## 主要思想

分治算法的主要思想是将原问题**递归**地分成若干个子问题，直到子问题**满足边界条件**，停止递归。将子问题逐个击破（一般是同种方法），将已经解决的子问题合并，最后，算法会**层层合并**（回溯？）得到原问题的答案。

## 分治算法的步骤

- 分：**递归**地将问题**分解**为各个子问题（性质相同的、相互独立的子问题）；
- 治：将这些规模更小的子问题**逐个击破**；
- 合：将已解决的子问题**逐层合并**，最终得出原问题的解。

![分治示意图.jpg](http://xyao-imgs.oss-cn-beijing.aliyuncs.com/img/分治思想.png)

## 分治算法适用的情况

- 原问题的**计算复杂度**随着问题的规模的增加而增加。
- 原问题**能够被分解**成更小的子问题。
- 子问题的**结构和性质**与原问题一样，并且**相互独立**，子问题之间**不包含**公共的子问题。
- 原问题分解出的子问题的解**可以合并**为该问题的解。

## 算法应用

### 169. 多数元素

#### 题目描述

给定一个大小为`n`的数组，找到其中的多数元素。多数元素是指在数组中出现次数**大于**`n/2`的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

#### 示例1

```
输入: [3,2,3]
输出: 3
```

#### 示例2

```
输入: [2,2,1,1,1,2,2]
输出: 2
```

#### 解题思路

这道题本身其实不用通过分治方法来求解，本质上就是求该数组的众数，由于题目中特别说明**该元素在数组中出现次数大于`n/2`**，我们将原数组排序后，直接取中间位置，即可。

#### 代码（排序法）

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        nums.sort()
        return nums[len(nums)//2]
```

不过出题的本意应该还是希望从分治思想来考虑这道题，具体的算法流程如下：

- 终止条件：子数组长度为`1`时，停止切分；若子数组长度为`0`则返回`None`。
- 划分子数组：递归地将原数组二分为左右两个子数组，直至达到终止条件。
- 处理子问题，并合并结果：
  - 长度为`1`的子数组中唯一的数显然是众数，直接返回即可。
  - 如果两个子数组的众数相同，那么显然整个区间的众数是相同值。
  - 如果两个子数组的众数不相同，比较两个众数在整个区间内出现的次数，次数多者为众数。

#### 代码（分治法）

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        if not nums: return None

        if len(nums) == 1: return nums[0]

        left = self.majorityElement(nums[:(len(nums)//2)])
        right = self.majorityElement(nums[(len(nums)//2):])

        if left == right:
            return left
        if nums.count(left) > nums.count(right):
            return left
        else:
            return right
```

---

### 53. 最大子序和

#### 题目描述

给定一个整数数组`nums`，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

#### 示例

```
输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

#### 进阶

如果你已经实现复杂度为$O(n)$的解法，尝试使用更为精妙的分治法求解。

#### 解题思路

这道题的$O(n)$解法其实比较容易想到，分治解法有着更高的时间复杂度，理解起来也更复杂。

我们可以知道，满足要求的连续子数组要么在左半边，要么在右半边，要么穿过中间，对于左半区间及右半区间，情况也是一样，因此可以用分治法来处理。

**举个例子说明**：如对于某数组`[a1, ..., a(n/2), ..., an]`，在递归过程中我们可以得到它左区间的最大和`left`以及右区间的最大和`right`，假设原数组的最大和连续子数组为`[ak, ..., am]`同时穿过左右两个区间，则我们对于左区间从右自左计算最大和；对于右区间从左自由计算最大和，则有`左区间最大和 = [ak, ..., a(n/2 - 1)]`，`有区间最大和 = [a(n/2), ..., am]`，两者相加即可，最终返回三者的最大值。

#### 代码

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        else:
            left = self.maxSubArray(nums[:(len(nums)//2)])
            right = self.maxSubArray(nums[(len(nums)//2):])
        
        max_left = nums[(len(nums)//2)-1]
        tmp = 0
        for i in range((len(nums)//2)-1, -1, -1):
            tmp += nums[i]
            max_left = max(max_left, tmp)
        
        max_right = nums[(len(nums)//2)]
        tmp = 0
        for i in range((len(nums)//2), len(nums)):
            tmp += nums[i]
            max_right = max(max_right, tmp)
        
        return max(left, right, max_left + max_right)
```

---

### 50. Pow(x, n)

#### 题目描述

实现`pow(x, n)`，即计算`x`的`n`次幂函数。

#### 示例1

```
输入: 2.00000, 10
输出: 1024.00000
```

#### 示例2

```
输入: 2.10000, 3
输出: 9.26100
```

#### 示例3

```
输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
```

#### 说明

- `-100.0 < x < 100.0`
- `n`是`32`位有符号整数，其数值范围是`[-2^31, 2^31 - 1]`

#### 解题思路

这其实就是实现快速幂算法。

对于指数运算$x^n$，若`n`为偶数，则$x^n = (x^2)^{(n/2)}$，以此类推，`n/2`可以继续二分；

若`n`为奇数，则$x^n = x\times x^{n-1}$，且`n-1`一定是偶数，可以继续二分。

#### 代码

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0: return 1
        if n < 0:
            n = -1 * n
            x = 1/x
        
        if n % 2 == 1:
            res = x * self.myPow(x, n-1)
            return res
        return self.myPow(x*x, n//2)
```

